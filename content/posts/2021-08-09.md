---
title: "Rubyのメモリ割り当て"
date: 2021-08-09
math: true
tags:
  - Ruby
  - Linux
---

とあるSaaS製品を開発保守している知り合いが、[Puma](https://github.com/puma/puma) (Rails) のメモリが高止まりしてしまう現象が起きていたが、記事 [Ruby: mallocでマルチスレッドプログラムのメモリが倍増する理由（翻訳）](https://techracho.bpsinc.jp/hachi8833/2017_12_28/50109) を参考に環境変数 `MALLOC_ARENA_MAX` をいじったら解決したと話していました。

自分も現在 Puma (Rails) で動いているSNSアプリのバックエンドを担当しています。
1日あたり180 ~ 250万のAPIリクエストが行われており、1つのインスタンスあたり `2 worker * 8~32 threads = 16~64 threads` でリクエストを処理しています。
今は特にメモリで困ってはいないですが、いつか同じ現象に悩まされるかもと思い、記事を読みつつ周辺知識を調べて深掘ってみました。

### メモリ割り当てで使われる3つのレイヤー
Ruby でのメモリ割り当てには3つのレイヤーが関与します。
- Ruby VM
- メモリアロケータ
- カーネル

Ruby VMではRubyのオブジェクトを管理がされています。

{{< figure src="/images/2021-08-09-1.svg" >}}

Rubyのオブジェクトは40byte固定で、オブジェクトが生成されるとヒープページ内のスロットに格納されます。
もし空きスロットがない場合は新たなヒープページを割り当てます。
また40byte以上のオブジェクトの場合はヒープページの外に格納し、スロットにはポインタが格納されます。
新たなヒープページの割り当て、ヒープページ外への格納、これはどちらもメモリアロケータが使われます。

メモリアロケータには glibc の `malloc()` と `free()` が使われます。
mallocは引数にメモリのサイズを自由に指定できる一方、配置される場所については何も保証されません。
メモリアロケータは余裕を持った大きさのメモリをカーネルから割り当てます。

カーネルはページ単位でメモリを割り当てます。ページサイズはx86_64アーキテクチャにおいては4KBです。
仮想記憶の仕組みを用いてメモリの物理アドレスは仮想アドレスに抽象化されます。カーネルというよりOS特有の仮想メモリマネージャと言い換えてもいいですね。

オブジェクトを生成すると Ruby ヒープページ → メモリアロケータ → カーネル → 物理メモリ と複数のレイヤーを通り、各レイヤーは必要な量よりも多めに割り当てます。
そしてRuby ヒープページには空スロットが存在し得えて、メモリアロケータが確保したヒープにも空きが存在し得ます。`top` コマンドでプロセスのメモリ使用量を見ると、カーネル観点でのメモリ使用量が表示されるだけなので、Ruby ヒープページでどのくらい使われているのか、メモリアロケータでどのくらい使われているかはわかりません。

### フラグメンテーション
フラグメンテーションは、使用中のメモリ領域が未使用領域を挟んで飛び飛びに配置される状態を指します。フラグメンテーションは Ruby ヒープページとメモリアロケータそれぞれで起こり得ます。

RubyではGCがヒープページの空きスロットを解放し、再利用可能な状態にしてくれます。
ヒープページ内のスロットが全て空き状態になれば、ページをメモリアロケータに解放することができます。
しかしGCによって空きスロットが飛び飛びになってしまうケースは往々にして起こり得ます。

{{< figure src="/images/2021-08-09-2.svg" >}}

一方メモリアロケータでも同様の事象が起き得ます。下の図は3KB, 2KB, 7KBを割り当てている状態から3KBの割り当てを解放しています。

{{< figure src="/images/2021-08-09-3.svg" >}}

カーネルのページ単位は4KBなので、これではページの解放ができません。
また下の図のように、空きが連続していない場合には大きく確保ができないため、新たにメモリを割り当てる必要があります。

{{< figure src="/images/2021-08-09-4.svg" >}}

このようにRuby ヒープページとメモリアロケータ、どちらもフラグメンテーションが起こります。
記事によると、Ruby自体のメモリ使用量は全体のメモリ使用量に与える影響は小さく、Rubyのヒープページのフラグメンテーションはあまり関係ないとの調査結果が載っています。
典型的なRailsアプリのメモリ使用量の50%〜80%は、たかが数バイトより大きなオブジェクトに空きメモリを割り当てるmalloc呼び出しによって占められてるとのことでした。

{{< tweet 879870368680255489 >}}

### mallocとarena
ではメモリアロケータで使われるmallocでは何が行われているのか。まずはプロセスのセグメント配置について書きます。

{{< figure src="/images/2021-08-09-5.svg" >}}

プロセスに割り当てられるメモリは1つの巨大な配列みたいなもので、64bit OSなら2^64byteのサイズを持ちます。
これは仮想メモリなので実際の物理メモリに2^64byte確保するのではなく、使った分だけ占有するようになってます。
ここにはプログラムを置く _text領域_ 、初期化されたグローバル変数を置く _data領域_ 、初期化されていない（データ領域だけ確保された）グローバル変数を置く _bss領域_ 、関数の引数やローカル変数を置く _stack領域_ 、プログラムのデータを置く _heap領域_ があります。

stackは関数呼び出しの際に使われ、リターンアドレス、引数、内部のローカル変数、戻り値を保持するために使われます。関数が終了すると自動的にクリアされるのでメモリ管理は気にしなくて良いですね。
heapはstackに置けないデータ、例えば関数をまたいで保持したいデータを格納するために使われます。ここにmallocで確保したメモリが来ます。heapで不要になったメモリは、自動でメモリ管理がされないので明示的にfreeを行うか、GCに解放してもらいます。

text、data、bssは実行する前からサイズが分かっている一方、heapとstackはプログラムの実行中にサイズが変わるものなのでどこにどう置けばいいのかわからないです。
そこで図のようにstackとheapを両端に配置し、使いたい分だけ領域を伸ばせるようになっています。

mallocでは最初に特定のサイズのheapを空きプールとして確保しますが、これには `sbrk()` が使われます。空きが足りなくなると随時sbrkを発行して補充をします。
そしてmallocはプロセスから要求されたサイズに応じてはchunkという単位で確保したプールからメモリを切り出します。
mallocによって確保されたメモリはfreeによって解放しますが、その時点でheap領域が減少するわけではありません。
未使用となったchunkは未使用リストにリンクされ管理されます。そして次の要求のあった時に必要に応じて再利用がされ、一定の条件を満たすとheap領域が減少されます。

これらメモリプールとメモリプールを管理するものを1つのまとまりとしてアリーナ(arena)と呼びます。
メモリプールの管理に使われるのは [`malloc_state`](https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#malloc_state) という構造体で、デフォルトで使用されるarenaの管理部はmain_arenaという変数名で静的に定義されています。
プログラムが起動された時点ではarenaはこのmain_arena1つだけが存在します。

このmalloc_stateの頭にはmutex用の領域があります。あるスレッドがmallocの管理するchunkのリストを繋ぎ変えている途中で別のスレッドがそのリストを別スレッドが同時に使ったら問題が起きます。
これを防ぐためにアリーナを使う前にアリーナをロックし、使い終わったら解放するという排他処理をしています。
main_arenaを触りにいったら他スレッドが使用中だった、しかしパフォーマンスのためにロック終了を待たずしてarenaを使いたい、このときにmallocは `mmap()` で新たなarenaを確保します。
このarenaの最大数はデフォルトでは仮想CPU数の8倍あるようで、2つのハイパースレッドを持つ2コアでは `2 * 2 * 8 = 32` ものarenaができます。これがフラグメンテーションの原因です。

arenaの個数を減らすとフラグメンテーションを軽減できる一方で、arenaのロックの競合が増加して実行速度が落ちる可能性があります。
このトレードオフの落とし所はどこか、これが `MALLOC_ARENA_MAX=2` 、つまりarenaの最大数が2のときメモリ使用が大幅に省エネになり、パフォーマンス低下はわずかということでした。

| Configuration | Memory Use |
| ----------- | ----------- |
| Base (unlimited arenas) | 1.73x |
| Base (before arenas introduced) | 1x |
| MALLOC_ARENA_MAX=1 | 0.86 |
| MALLOC_ARENA_MAX=2 | 0.87 |

| Configuration | Response Time |
| ----------- | ----------- |
| Base (unlimited arenas) | 0.9x |
| Base (before arenas introduced) | 1x |
| MALLOC_ARENA_MAX=1 | 1.15x |
| MALLOC_ARENA_MAX=2 | 1.03x |

ちなみになぜデフォルトでは8なのか。
記事によると、メモリアロケータの開発元はRedHatであり、彼らの顧客は大量のRAMを搭載できる企業です。
大量のメモリを使用してマルチスレッドのパフォーマンスを少しでも上げることがRedHatの顧客にとって正しいトレードオフです。
メモリを潤沢に使いたくない、ミニマムな構成にしたい人にとってはこれは当てはまらないですね。

arenaの最大数を減らす以外にも、記事にはメモリアロケータを [`jemalloc`](https://github.com/jemalloc/jemalloc) に変える案も載っていました。
jemallocはmallocで発生するフラグメンテーションを回避する設計になっており、mallocよりずっと少ないメモリ使用でmallocと同等かそれ以上のパフォーマンスが出るようです。jemallocではメモリ割り当ての最小サイズがmallocよりも小さく、[アプリケーションによっては10%-12%改善される](https://docs.google.com/presentation/d/1-WrYwz-QnSI9yeRZfCCgUno-KOMuggiGHlmOETXZy9c/edit#slide=id.p) という話がRubyKaigiの資料に載っていました。
jemallocをデフォルトのアロケータにしてくれないんですかね? :(

### おわりに
メモリ使用が激しいとき、メモリリークを真っ先に疑ってしまいます。
エンジニアが書いたコードに問題があるケースの方が多いとは思いますが、このように低レイヤーを知っていることで原因調査のときに自分の引き出しを増やせて、スムーズに問題解決できるかもしれません。

メモリ割り当てにmallocが使われてフラグメンテーションが起こるというのはRubyに限らず、他言語でも発生する現象だと思います。
[Decreasing RAM Usage by 40% Using jemalloc with Python & Celery](https://zapier.com/engineering/celery-python-jemalloc/) というPythonでのメモリの記事も見つけたので、今回のRubyによるメモリ割り当てを深掘った知識は汎用的と言えそうです。やったね :)

### 参考
- TechRacho - https://techracho.bpsinc.jp/hachi8833/2017_12_28/50109
- glibc wiki - https://sourceware.org/glibc/wiki/MallocInternals
- Qiita - https://qiita.com/kaityo256/items/9e78b507940b2292bf79
- 技術文書 - https://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/
- 書籍「Linuxのしくみ」 - https://www.amazon.co.jp/dp/B079YJS1J1
