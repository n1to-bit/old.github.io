---
title: "OR-Tools で解く Vehicle Routing Problem"
date: 2018-12-28
tags:
  - VRP
---

現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。
デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。

ユーザーの業種は幅広いのですが、その中でも通所介護や通所リハビリテーション (以後 デイケア) を行っている事業所が一定の割合を占めています。
デイケアでは朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。

各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。
事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。
それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。

ユーザーヒアリングを行ったときに、いくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。

これを解決するためのツールはないかなと探していると [Google OR-Tools](https://developers.google.com/optimization) というライブラリを発見したのでこれを試しに使ってみました。
OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。
OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。

今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。
VRP は [NP-hard (NP困難)](https://ja.wikipedia.org/wiki/NP%E5%9B%B0%E9%9B%A3) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。
OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているようで、ググると論文がヒットします。

VRP はどんなものか、OR-Tools の Guide に載ってる図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)

{{< figure src="/images/2018-12-28-1.svg" >}}

真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車両を使います。ノード内の数字は ID です。

VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。
ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。
ありがたいことに Google Map には [Distance Matrix API](https://developers.google.com/optimization/routing/vrp#distance_matrix_api) があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。ただし16個までしか配列を送れません。もし32個の地点の distance matrix を得たい場合には API を4回 call する必要があります。

distance matrix がわかったら `DataModel` を作成します。

```cpp
struct DataModel {
    const std::vector<std::vector<int64_t>> distance_matrix{
        {0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468,
         776, 662},
        {548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674,
         1016, 868, 1210},
        {776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130,
         788, 1552, 754},
        {696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822,
         1164, 560, 1358},
        {582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708,
         1050, 674, 1244},
        {274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514,
         1050, 708},
        {502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514,
         1278, 480},
        {194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662,
         742, 856},
        {308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320,
         1084, 514},
        {194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274,
         810, 468},
        {536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730,
         388, 1152, 354},
        {502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308,
         650, 274, 844},
        {388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536,
         388, 730},
        {354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342,
         422, 536},
        {468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342,
         0, 764, 194},
        {776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388,
         422, 764, 0, 798},
        {662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536,
         194, 798, 0},
    };
    const int num_vehicles = 4;
    const RoutingIndexManager::NodeIndex depot{0};
};
```

この `DataModel` を使って `RoutingIndexManager` を作り、それを用いて `RoutingModel` を作成します。

```cpp
RoutingIndexManager manager(data.distance_matrix.size(), data.num_vehicles,
                            data.depot);
RoutingModel routing(manager);
```

また計算結果の走行距離を取得し、それに対して重みをつけたいので `RegisterTransitCallback()` で callback を作成します。

```cpp
const int transit_callback_index = routing.RegisterTransitCallback(
    [&data, &manager](int64_t from_index, int64_t to_index) -> int64_t {
      // Convert from routing variable Index to distance matrix NodeIndex.
      auto from_node = manager.IndexToNode(from_index).value();
      auto to_node = manager.IndexToNode(to_index).value();
      return data.distance_matrix[from_node][to_node];
    });
routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index);
```

次にパラメータ調整をします。

`SetGlobalSpanCostCoefficient()` では各車両のルートの中で最も所要時間の長いルートをできるだけ小さくしようとする際に用いられる重み、コストです。
`0` の場合は考慮がされないので、アルゴリズムは全車両合計の総走行時間が短くなるのであれば、ごく少数の車両に多くの利用者を割り当てて非常に長いルートを作成する一方、残りの車両にはゼロかごく少数の利用者だけを割り当てるような偏りの大きなルートができます。
デイケア事業においては持っているリソース (車両および人員) をできるだけフル活用し、送迎にかかる時間を短くしたい、かつあまり偏りが出ないようにしたいというケースが多いので、この値を調整する必要があります。

ちなみに各ノードごとにも重みをつけることができ、そのノードを通らなかった場合にペナルティとしてコストをプラスさせることができます[Penalties and Dropping Visits](https://developers.google.com/optimization/routing/penalties)。 
GlobalSpanCost の値はペナルティと合わせて調整しないと、ノードを全く通らずペナルティを受け入れるルート結果が出たりします。

```cpp
routing.AddDimension(transit_callback_index, 0, 3000, true, "Distance");
routing.GetMutableDimension("Distance")->SetGlobalSpanCostCoefficient(100);
```

最後に `SolveWithParameters()` で結果が出力されます。結果を図示したもの↓

{{< figure src="/images/2018-12-28-2.svg" >}}

しかしこれでは各利用者をピックアップすべき時間が設定できていません。OR-Tools では Time Window 制約にも対応しており、10時から送迎がスタートしてAさんの家には10:10~10:15、Bさんの家には10:30~10:45に行く、といった問題設定も可能です。なので時間制約の問題はクリアできます。
[Vehicle Routing Problem with Time Windows](https://developers.google.com/optimization/routing/vrptw)

{{< figure src="/images/2018-12-28-3.svg" >}}

あとは乗客人数制約です。デイケアの送迎に使われる車両はワゴン車が多く、せいぜい5~6人の利用者しか乗せられないので、1つの車両が1度施設に帰ってきて利用者をおろし、再び別の人のピックアップにいくといったことがあります。
ありがたいことにこれも OR-Tools で解決できます [Capacity Constraints](https://developers.google.com/optimization/routing/cvrp)。ただし利用者には特性があり、車椅子の方は専用の車両しか使えない、その車両には車椅子ではない方も何人か乗せられるといったケースもよくあるので、ここは工夫しないと実現できないです。

{{< figure src="/images/2018-12-28-4.svg" >}}

というわけでなんとか OR-Tools を使ってデイケアの送迎のルート計画はできるかも、という兆しが見えました。

注意点としてはメタヒューリスティクスを用いているので最適性の保証はないです。つまり必ずしも全体最適解が求まるとは限りません。
条件によっては結果が悪くなるケース、複雑すぎて結果が出ないケースも出てくるので、その際にはパラメータで探索戦略を変えて試す必要があると思います。探索戦略には焼きなまし法、タブー探索法、貪欲法などあります。一部しか知らないので勉強してみる所存。(https://developers.google.com/optimization/routing/routing_options)
