<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Network on nito95 blog</title>
    <link>https://nito95.github.io/categories/network/</link>
    <description>Recent content in Network on nito95 blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 10 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://nito95.github.io/categories/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CでTCPソケットプログラミング</title>
      <link>https://nito95.github.io/posts/2020-04-10/</link>
      <pubDate>Fri, 10 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nito95.github.io/posts/2020-04-10/</guid>
      <description>今関わっているプロジェクトで、3rd Party製のドラレコから流れるGPSと動画データを弊社のプラットフォームに投げ込むアダプターの開発をしています。
この3rd Partyデバイスとの通信方法が独自規格でして。。。通信方法について書かれたPDFがあり、こうやって通信を開始してね、このタイミングでACKしてね、危険運転があったらこういうバイナリを送るよ、とか詳細に書いてあるわけです。
ベテランのバックエンドエンジニアの人やファームウェアの人が通信部分をゴリゴリ作ってくださったのですが、コードを読んでも何がなんだかサッパリわかりませんでした。Ruby言語自体のコードの中身を見て、そこに書かれたCのコードを読んで、システムコールの仕様を調べては「よくわからんぞ」となっておりました。 そのときに「ソケットプログラミングしてみるといいよ」とアドバイスをもらったので、C言語でTCPソケットを実装してお勉強してみました。
ちなみにネットワークに関しての知識は
「マスタリング TCP/IP 入門編」 「Real World HTTP - 歴史とコードに学ぶインターネットとウェブ技術」 の書籍を読んだことがある程度です。
TCPプログラミング こちらのサイトを参考にさせていただきました Geekなぺーじ Linuxネットワークプログラミング
サーバー サーバーはクライアントからの接続要求を待ちますが、どのように待つか設定します。
ソケットを作る IPアドレスとポートを設定する クライアントから通信接続要求が来るまでプログラムを停止し接続後にプログラムを再開する データを送信する ソケットを閉じて通信接続を終了する クライアント クライアントは特定のIPアドレス、TCPポート番号で接続待ちをするサーバーに対して接続要求を出します。
ソケットを作る 接続先の指定 接続する サーバーからデータを受信 今回作ったもののソケットAPI callのサーバー、クライアントの関係を表すとこんな感じです。
ソースコードはこちら nito95/clang-socket-programming
サーバーもクライアントもローカルなのでクライアント側で設定した接続先のIPは127.0.0.1ですが、ここは本来 gethostbyname でWinSockに名前解決を任せます。
これはサーバーとクライアントが繋がるとサーバーからクライアントにメッセージが送られ接続が切れる、という片手落ちなものです。 サーバーとしてあるべきはマルチスレッドで複数のクライアントと接続し、クライアントからの要求を受けたらクライアントにメッセージを返し、接続を切り再び接続要求待ち状態にするのがよいですね。
初めてOSI参照モデルでいうL3まで下りて理解が深まりました。これ以降は全然作り込んではないですが、もしCで基本的なライブラリだけでサーバーとクライアントを作ってみる系の良い教材があれば試してみたいなと思います。</description>
    </item>
    
    <item>
      <title>Design Docを書く文化</title>
      <link>https://nito95.github.io/posts/2020-01-14/</link>
      <pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://nito95.github.io/posts/2020-01-14/</guid>
      <description>今所属しているベンチャーで、何か機能を開発する際にはまずDesign Docを書いていこうという文化ができてきました。
それまでは Jira に &amp;ldquo;〜機能&amp;rdquo; のような抽象的な大きなタスクを切って、そこからサブタスクを切って消化していくだけでしたが、まず最初にDesign Docを作るというタスクから始まるようになりました。
Design Docとは 一般的なDesign Docは設計仕様書のことですが、今参考にしているDesign DocはGoogleで使われているDesign Docです。弊社では
目的 背景 スコープ 達成すべき要件と優先度付け (MUST, OPTIONALなどRFC的に) システム設計 UI設計 タスク出しと簡単な見積もり などについて書きます。
そしてチームメンバーに共有し、これで行こうとなってから初めてタスクをスプリントに乗せることになります。
ちなみに参考にしたGoogleのDesign Docのテンプレートは こちら
意義 最初はちょっと面倒だなーと思っていましたが、今はメリットをひしひしと実感してます。
まずは &amp;ldquo;自分の脳内整理のための道具&amp;rdquo; の側面です。ユーザーからの要望がCSチームからチケットで上がり、CSの温度感が高いのでこういう機能を作ろう、となるケースが多かったのですが、Design Docを書いているときに これ本当に必要か? これが目的だから別の方法でも解決できるよね など、ユーザーに価値を届けるために本当にそれがベストなのか考えるきっかけとなります。 エンジニアをしているとコードをガリガリ書いていきたいのでつい新機能を作っていく方向になりがちですが、そもそも作らなくてよい方法があればそのほうがメンテコストはかからないし別のことに時間を割けます。
あと &amp;ldquo;他人への共有&amp;rdquo; の側面です。他のエンジニアがPRレビューするときに目的や背景がわかっていないと適切なレビューはできないので、PRには必ずDesign Docのリンクを貼ってレビュー時にも見てもらうようにしています。また、他人が意味するところに 将来の自分や将来メンテする他人 も含まれます。 機能が使われなくなったり、負債が溜まって改修しようと思った際に、そもそもどんな目的でこれは作られたのか、が大事な判断材料となり得ます。思わぬ影響範囲に気づくことにもあります。
ベンチャーではいかにユーザーに早く価値を提供できるか、というのが最も大事です。そもそもこれが良い価値だっけ? を考えるきっかけとなり、メンバーにわかりやすい形で共有することで一丸となって同じ方向を向けてスピードが出る、時間が経った後に選択を迫られた際に振り返れることでロスの多い選択をしない、これらの意味で大事だなあと思いました。</description>
    </item>
    
  </channel>
</rss>
