<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>OR-Tools で解く Vehicle Routing Problem | nito95 blog</title>
<meta name=keywords content="VRP">
<meta name=description content="現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。
ユーザーの業種は幅広いのですが、その中でも通所介護や通所リハビリテーション (以後 デイケア) を行っている事業所が一定の割合を占めています。 デイケアでは朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。
各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。
ユーザーヒアリングを行ったときに、いくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。
これを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。 OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。
今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているようで、ググると論文がヒットします。
VRP はどんなものか、OR-Tools の Guide に載ってる図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)
  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車両を使います。ノード内の数字は ID です。
VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。 ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。ただし16個までしか配列を送れません。もし32個の地点の distance matrix を得たい場合には API を4回 call する必要があります。">
<meta name=author content>
<link rel=canonical href=https://nito95.github.io/posts/2018-12-28/>
<meta name=google-site-verification content="G-FT3WYS86E7">
<link rel=stylesheet href=https://nito95.github.io/css/custom.css>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.0">
<meta property="og:title" content="OR-Tools で解く Vehicle Routing Problem">
<meta property="og:description" content="現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。
ユーザーの業種は幅広いのですが、その中でも通所介護や通所リハビリテーション (以後 デイケア) を行っている事業所が一定の割合を占めています。 デイケアでは朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。
各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。
ユーザーヒアリングを行ったときに、いくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。
これを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。 OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。
今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているようで、ググると論文がヒットします。
VRP はどんなものか、OR-Tools の Guide に載ってる図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)
  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車両を使います。ノード内の数字は ID です。
VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。 ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。ただし16個までしか配列を送れません。もし32個の地点の distance matrix を得たい場合には API を4回 call する必要があります。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nito95.github.io/posts/2018-12-28/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-12-28T00:00:00+00:00">
<meta property="article:modified_time" content="2018-12-28T00:00:00+00:00"><meta property="og:site_name" content="nito95">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="OR-Tools で解く Vehicle Routing Problem">
<meta name=twitter:description content="現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。
ユーザーの業種は幅広いのですが、その中でも通所介護や通所リハビリテーション (以後 デイケア) を行っている事業所が一定の割合を占めています。 デイケアでは朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。
各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。
ユーザーヒアリングを行ったときに、いくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。
これを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。 OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。
今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているようで、ググると論文がヒットします。
VRP はどんなものか、OR-Tools の Guide に載ってる図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)
  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車両を使います。ノード内の数字は ID です。
VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。 ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。ただし16個までしか配列を送れません。もし32個の地点の distance matrix を得たい場合には API を4回 call する必要があります。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nito95.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OR-Tools で解く Vehicle Routing Problem","item":"https://nito95.github.io/posts/2018-12-28/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OR-Tools で解く Vehicle Routing Problem","name":"OR-Tools で解く Vehicle Routing Problem","description":"現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。\nユーザーの業種は幅広いのですが、その中でも通所介護や通所リハビリテーション (以後 デイケア) を行っている事業所が一定の割合を占めています。 デイケアでは朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。\n各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。\nユーザーヒアリングを行ったときに、いくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。\nこれを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。 OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。\n今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているようで、ググると論文がヒットします。\nVRP はどんなものか、OR-Tools の Guide に載ってる図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)\n  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車両を使います。ノード内の数字は ID です。\nVRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。 ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。ただし16個までしか配列を送れません。もし32個の地点の distance matrix を得たい場合には API を4回 call する必要があります。","keywords":["VRP"],"articleBody":"現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。\nユーザーの業種は幅広いのですが、その中でも通所介護や通所リハビリテーション (以後 デイケア) を行っている事業所が一定の割合を占めています。 デイケアでは朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。\n各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。\nユーザーヒアリングを行ったときに、いくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。\nこれを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。 OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。\n今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているようで、ググると論文がヒットします。\nVRP はどんなものか、OR-Tools の Guide に載ってる図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)\n  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車両を使います。ノード内の数字は ID です。\nVRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。 ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。ただし16個までしか配列を送れません。もし32個の地点の distance matrix を得たい場合には API を4回 call する必要があります。\ndistance matrix がわかったら DataModel を作成します。\nstruct DataModel { const std::vectorstd::vectorint64_t distance_matrix{ {0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662}, {548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210}, {776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754}, {696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358}, {582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244}, {274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708}, {502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480}, {194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856}, {308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514}, {194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468}, {536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354}, {502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844}, {388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730}, {354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536}, {468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194}, {776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798}, {662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0}, }; const int num_vehicles = 4; const RoutingIndexManager::NodeIndex depot{0}; }; この DataModel を使って RoutingIndexManager を作り、それを用いて RoutingModel を作成します。\nRoutingIndexManager manager(data.distance_matrix.size(), data.num_vehicles, data.depot); RoutingModel routing(manager); また計算結果の走行距離を取得し、それに対して重みをつけたいので RegisterTransitCallback() で callback を作成します。\nconst int transit_callback_index = routing.RegisterTransitCallback( [\u0026data, \u0026manager](int64_t from_index, int64_t to_index) - int64_t { // Convert from routing variable Index to distance matrix NodeIndex.  auto from_node = manager.IndexToNode(from_index).value(); auto to_node = manager.IndexToNode(to_index).value(); return data.distance_matrix[from_node][to_node]; }); routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index); 次にパラメータ調整をします。\nSetGlobalSpanCostCoefficient() では各車両のルートの中で最も所要時間の長いルートをできるだけ小さくしようとする際に用いられる重み、コストです。 0 の場合は考慮がされないので、アルゴリズムは全車両合計の総走行時間が短くなるのであれば、ごく少数の車両に多くの利用者を割り当てて非常に長いルートを作成する一方、残りの車両にはゼロかごく少数の利用者だけを割り当てるような偏りの大きなルートができます。 デイケア事業においては持っているリソース (車両および人員) をできるだけフル活用し、送迎にかかる時間を短くしたい、かつあまり偏りが出ないようにしたいというケースが多いので、この値を調整する必要があります。\nちなみに各ノードごとにも重みをつけることができ、そのノードを通らなかった場合にペナルティとしてコストをプラスさせることができますPenalties and Dropping Visits。 GlobalSpanCost の値はペナルティと合わせて調整しないと、ノードを全く通らずペナルティを受け入れるルート結果が出たりします。\nrouting.AddDimension(transit_callback_index, 0, 3000, true, \"Distance\"); routing.GetMutableDimension(\"Distance\")-SetGlobalSpanCostCoefficient(100); 最後に SolveWithParameters() で結果が出力されます。結果を図示したもの↓\n  しかしこれでは各利用者をピックアップすべき時間が設定できていません。OR-Tools では Time Window 制約にも対応しており、10時から送迎がスタートしてAさんの家には10:10~10:15、Bさんの家には10:30~10:45に行く、といった問題設定も可能です。なので時間制約の問題はクリアできます。 Vehicle Routing Problem with Time Windows\n  あとは乗客人数制約です。デイケアの送迎に使われる車両はワゴン車が多く、せいぜい5~6人の利用者しか乗せられないので、1つの車両が1度施設に帰ってきて利用者をおろし、再び別の人のピックアップにいくといったことがあります。 ありがたいことにこれも OR-Tools で解決できます Capacity Constraints。ただし利用者には特性があり、車椅子の方は専用の車両しか使えない、その車両には車椅子ではない方も何人か乗せられるといったケースもよくあるので、ここは工夫しないと実現できないです。\n  というわけでなんとか OR-Tools を使ってデイケアの送迎のルート計画はできるかも、という兆しが見えました。\n注意点としてはメタヒューリスティクスを用いているので最適性の保証はないです。つまり必ずしも全体最適解が求まるとは限りません。 条件によっては結果が悪くなるケース、複雑すぎて結果が出ないケースも出てくるので、その際にはパラメータで探索戦略を変えて試す必要があると思います。探索戦略には焼きなまし法、タブー探索法、貪欲法などあります。一部しか知らないので勉強してみる所存。(https://developers.google.com/optimization/routing/routing_options)\n","wordCount":"491","inLanguage":"en","datePublished":"2018-12-28T00:00:00Z","dateModified":"2018-12-28T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://nito95.github.io/posts/2018-12-28/"},"publisher":{"@type":"Organization","name":"nito95 blog","logo":{"@type":"ImageObject","url":"https://nito95.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://nito95.github.io/ accesskey=h title="nito95 blog (Alt + H)">nito95 blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://nito95.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
OR-Tools で解く Vehicle Routing Problem
</h1>
<div class=post-meta>December 28, 2018
</div>
</header>
<div class=post-content><p>現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。
デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。</p>
<p>ユーザーの業種は幅広いのですが、その中でも通所介護や通所リハビリテーション (以後 デイケア) を行っている事業所が一定の割合を占めています。
デイケアでは朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。</p>
<p>各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。
事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。
それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。</p>
<p>ユーザーヒアリングを行ったときに、いくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。</p>
<p>これを解決するためのツールはないかなと探していると <a href=https://developers.google.com/optimization>Google OR-Tools</a> というライブラリを発見したのでこれを試しに使ってみました。
OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。
OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。</p>
<p>今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。
VRP は <a href=https://ja.wikipedia.org/wiki/NP%E5%9B%B0%E9%9B%A3>NP-hard (NP困難)</a> に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。
OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているようで、ググると論文がヒットします。</p>
<p>VRP はどんなものか、OR-Tools の Guide に載ってる図を拝借して書きます。 (<a href=https://developers.google.com/optimization/routing/vrp>https://developers.google.com/optimization/routing/vrp</a>)</p>
<figure>
<img loading=lazy src=/images/2018-12-28-1.svg>
</figure>
<p>真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車両を使います。ノード内の数字は ID です。</p>
<p>VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。
ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。
ありがたいことに Google Map には <a href=https://developers.google.com/optimization/routing/vrp#distance_matrix_api>Distance Matrix API</a> があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。ただし16個までしか配列を送れません。もし32個の地点の distance matrix を得たい場合には API を4回 call する必要があります。</p>
<p>distance matrix がわかったら <code>DataModel</code> を作成します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DataModel</span> {
    <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;&gt;</span> distance_matrix{
        {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>548</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>468</span>,
         <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>662</span>},
        {<span style=color:#ae81ff>548</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>684</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>594</span>, <span style=color:#ae81ff>480</span>, <span style=color:#ae81ff>674</span>,
         <span style=color:#ae81ff>1016</span>, <span style=color:#ae81ff>868</span>, <span style=color:#ae81ff>1210</span>},
        {<span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>684</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>992</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>1130</span>,
         <span style=color:#ae81ff>788</span>, <span style=color:#ae81ff>1552</span>, <span style=color:#ae81ff>754</span>},
        {<span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>992</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>844</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>1232</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>822</span>,
         <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>560</span>, <span style=color:#ae81ff>1358</span>},
        {<span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>1118</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>708</span>,
         <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>674</span>, <span style=color:#ae81ff>1244</span>},
        {<span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>228</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>240</span>, <span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>514</span>,
         <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>708</span>},
        {<span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>228</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>1004</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>856</span>, <span style=color:#ae81ff>514</span>,
         <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>480</span>},
        {<span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>320</span>, <span style=color:#ae81ff>662</span>,
         <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>856</span>},
        {<span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>844</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>320</span>,
         <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>514</span>},
        {<span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>240</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>274</span>,
         <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>468</span>},
        {<span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>1232</span>, <span style=color:#ae81ff>1118</span>, <span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>730</span>,
         <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>1152</span>, <span style=color:#ae81ff>354</span>},
        {<span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>594</span>, <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>1004</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>308</span>,
         <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>844</span>},
        {<span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>480</span>, <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>536</span>,
         <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>},
        {<span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>674</span>, <span style=color:#ae81ff>1130</span>, <span style=color:#ae81ff>822</span>, <span style=color:#ae81ff>708</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>856</span>, <span style=color:#ae81ff>320</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>342</span>,
         <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>536</span>},
        {<span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>1016</span>, <span style=color:#ae81ff>788</span>, <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>320</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>342</span>,
         <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>194</span>},
        {<span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>868</span>, <span style=color:#ae81ff>1552</span>, <span style=color:#ae81ff>560</span>, <span style=color:#ae81ff>674</span>, <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>1152</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>388</span>,
         <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>798</span>},
        {<span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>1210</span>, <span style=color:#ae81ff>754</span>, <span style=color:#ae81ff>1358</span>, <span style=color:#ae81ff>1244</span>, <span style=color:#ae81ff>708</span>, <span style=color:#ae81ff>480</span>, <span style=color:#ae81ff>856</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>844</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>536</span>,
         <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>798</span>, <span style=color:#ae81ff>0</span>},
    };
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> num_vehicles <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
    <span style=color:#66d9ef>const</span> RoutingIndexManager<span style=color:#f92672>::</span>NodeIndex depot{<span style=color:#ae81ff>0</span>};
};
</code></pre></div><p>この <code>DataModel</code> を使って <code>RoutingIndexManager</code> を作り、それを用いて <code>RoutingModel</code> を作成します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>RoutingIndexManager <span style=color:#a6e22e>manager</span>(data.distance_matrix.size(), data.num_vehicles,
                            data.depot);
RoutingModel <span style=color:#a6e22e>routing</span>(manager);
</code></pre></div><p>また計算結果の走行距離を取得し、それに対して重みをつけたいので <code>RegisterTransitCallback()</code> で callback を作成します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> transit_callback_index <span style=color:#f92672>=</span> routing.RegisterTransitCallback(
    [<span style=color:#f92672>&amp;</span>data, <span style=color:#f92672>&amp;</span>manager](<span style=color:#66d9ef>int64_t</span> from_index, <span style=color:#66d9ef>int64_t</span> to_index) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>int64_t</span> {
      <span style=color:#75715e>// Convert from routing variable Index to distance matrix NodeIndex.
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>auto</span> from_node <span style=color:#f92672>=</span> manager.IndexToNode(from_index).value();
      <span style=color:#66d9ef>auto</span> to_node <span style=color:#f92672>=</span> manager.IndexToNode(to_index).value();
      <span style=color:#66d9ef>return</span> data.distance_matrix[from_node][to_node];
    });
routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index);
</code></pre></div><p>次にパラメータ調整をします。</p>
<p><code>SetGlobalSpanCostCoefficient()</code> では各車両のルートの中で最も所要時間の長いルートをできるだけ小さくしようとする際に用いられる重み、コストです。
<code>0</code> の場合は考慮がされないので、アルゴリズムは全車両合計の総走行時間が短くなるのであれば、ごく少数の車両に多くの利用者を割り当てて非常に長いルートを作成する一方、残りの車両にはゼロかごく少数の利用者だけを割り当てるような偏りの大きなルートができます。
デイケア事業においては持っているリソース (車両および人員) をできるだけフル活用し、送迎にかかる時間を短くしたい、かつあまり偏りが出ないようにしたいというケースが多いので、この値を調整する必要があります。</p>
<p>ちなみに各ノードごとにも重みをつけることができ、そのノードを通らなかった場合にペナルティとしてコストをプラスさせることができます<a href=https://developers.google.com/optimization/routing/penalties>Penalties and Dropping Visits</a>。
GlobalSpanCost の値はペナルティと合わせて調整しないと、ノードを全く通らずペナルティを受け入れるルート結果が出たりします。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>routing.AddDimension(transit_callback_index, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>3000</span>, true, <span style=color:#e6db74>&#34;Distance&#34;</span>);
routing.GetMutableDimension(<span style=color:#e6db74>&#34;Distance&#34;</span>)<span style=color:#f92672>-&gt;</span>SetGlobalSpanCostCoefficient(<span style=color:#ae81ff>100</span>);
</code></pre></div><p>最後に <code>SolveWithParameters()</code> で結果が出力されます。結果を図示したもの↓</p>
<figure>
<img loading=lazy src=/images/2018-12-28-2.svg>
</figure>
<p>しかしこれでは各利用者をピックアップすべき時間が設定できていません。OR-Tools では Time Window 制約にも対応しており、10時から送迎がスタートしてAさんの家には10:10~10:15、Bさんの家には10:30~10:45に行く、といった問題設定も可能です。なので時間制約の問題はクリアできます。
<a href=https://developers.google.com/optimization/routing/vrptw>Vehicle Routing Problem with Time Windows</a></p>
<figure>
<img loading=lazy src=/images/2018-12-28-3.svg>
</figure>
<p>あとは乗客人数制約です。デイケアの送迎に使われる車両はワゴン車が多く、せいぜい5~6人の利用者しか乗せられないので、1つの車両が1度施設に帰ってきて利用者をおろし、再び別の人のピックアップにいくといったことがあります。
ありがたいことにこれも OR-Tools で解決できます <a href=https://developers.google.com/optimization/routing/cvrp>Capacity Constraints</a>。ただし利用者には特性があり、車椅子の方は専用の車両しか使えない、その車両には車椅子ではない方も何人か乗せられるといったケースもよくあるので、ここは工夫しないと実現できないです。</p>
<figure>
<img loading=lazy src=/images/2018-12-28-4.svg>
</figure>
<p>というわけでなんとか OR-Tools を使ってデイケアの送迎のルート計画はできるかも、という兆しが見えました。</p>
<p>注意点としてはメタヒューリスティクスを用いているので最適性の保証はないです。つまり必ずしも全体最適解が求まるとは限りません。
条件によっては結果が悪くなるケース、複雑すぎて結果が出ないケースも出てくるので、その際にはパラメータで探索戦略を変えて試す必要があると思います。探索戦略には焼きなまし法、タブー探索法、貪欲法などあります。一部しか知らないので勉強してみる所存。(<a href=https://developers.google.com/optimization/routing/routing_options>https://developers.google.com/optimization/routing/routing_options</a>)</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://nito95.github.io/tags/vrp/>VRP</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://nito95.github.io/posts/2020-01-14/>
<span class=title>« Prev Page</span>
<br>
<span>Design Docを書く文化</span>
</a>
<a class=next href=https://nito95.github.io/posts/2018-12-11/>
<span class=title>Next Page »</span>
<br>
<span>F1 2018のTelemetryをGoでパースしてInfluxDBに流してGrafanaで描画してみる</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://nito95.github.io/>nito95 blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>