<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>OR-Tools で解く Vehicle Routing Problem | nito95 blog</title>
<meta name=keywords content="VRP">
<meta name=description content="現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。
ユーザーの業種は幅広いのですが、その中でも介護・福祉業界のユーザーが一定の割合を占めています。 例えばデイケアの事業所では朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。
各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。
SmartDrive Fleet を使っているいくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。
これを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。
OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。
今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているみたいです。
VRP はどんなものか、OR-Tools の Guide に載ってる例と図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)
  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車を使い、各車は最大で4人まで利用者を載せられることとします。ノード内の数字は ID です。
VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。
ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。しかしこのAPIは上限があり、16個までしか配列を送れません。">
<meta name=author content>
<link rel=canonical href=https://nito95.github.io/posts/2018-12-28/>
<meta name=google-site-verification content="G-FT3WYS86E7">
<link rel=stylesheet href=https://nito95.github.io/css/custom.css>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.35cd0f65a15cafa92372b8313deef5960aae04b90ad722f2bbf509eb0468137e.css integrity="sha256-Nc0PZaFcr6kjcrgxPe71lgquBLkK1yLyu/UJ6wRoE34=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=16x16 href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=icon type=image/png sizes=32x32 href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=apple-touch-icon href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<link rel=mask-icon href=https://nito95.github.io/%3Clink%20/%20abs%20url%3E>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.0">
<meta property="og:title" content="OR-Tools で解く Vehicle Routing Problem">
<meta property="og:description" content="現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。
ユーザーの業種は幅広いのですが、その中でも介護・福祉業界のユーザーが一定の割合を占めています。 例えばデイケアの事業所では朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。
各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。
SmartDrive Fleet を使っているいくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。
これを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。
OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。
今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているみたいです。
VRP はどんなものか、OR-Tools の Guide に載ってる例と図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)
  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車を使い、各車は最大で4人まで利用者を載せられることとします。ノード内の数字は ID です。
VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。
ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。しかしこのAPIは上限があり、16個までしか配列を送れません。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nito95.github.io/posts/2018-12-28/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-12-28T00:00:00+00:00">
<meta property="article:modified_time" content="2018-12-28T00:00:00+00:00"><meta property="og:site_name" content="nito95">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="OR-Tools で解く Vehicle Routing Problem">
<meta name=twitter:description content="現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。
ユーザーの業種は幅広いのですが、その中でも介護・福祉業界のユーザーが一定の割合を占めています。 例えばデイケアの事業所では朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。
各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。
SmartDrive Fleet を使っているいくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。
これを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。
OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。
今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているみたいです。
VRP はどんなものか、OR-Tools の Guide に載ってる例と図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)
  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車を使い、各車は最大で4人まで利用者を載せられることとします。ノード内の数字は ID です。
VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。
ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。しかしこのAPIは上限があり、16個までしか配列を送れません。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://nito95.github.io/posts/"},{"@type":"ListItem","position":2,"name":"OR-Tools で解く Vehicle Routing Problem","item":"https://nito95.github.io/posts/2018-12-28/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OR-Tools で解く Vehicle Routing Problem","name":"OR-Tools で解く Vehicle Routing Problem","description":"現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。\nユーザーの業種は幅広いのですが、その中でも介護・福祉業界のユーザーが一定の割合を占めています。 例えばデイケアの事業所では朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。\n各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。\nSmartDrive Fleet を使っているいくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。\nこれを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。\nOR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。\n今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているみたいです。\nVRP はどんなものか、OR-Tools の Guide に載ってる例と図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)\n  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車を使い、各車は最大で4人まで利用者を載せられることとします。ノード内の数字は ID です。\nVRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。\nちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。しかしこのAPIは上限があり、16個までしか配列を送れません。","keywords":["VRP"],"articleBody":"現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。 デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。\nユーザーの業種は幅広いのですが、その中でも介護・福祉業界のユーザーが一定の割合を占めています。 例えばデイケアの事業所では朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。\n各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。 事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。 それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。\nSmartDrive Fleet を使っているいくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。\nこれを解決するためのツールはないかなと探していると Google OR-Tools というライブラリを発見したのでこれを試しに使ってみました。\nOR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。 OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。\n今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。 VRP は NP-hard (NP困難) に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。 OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているみたいです。\nVRP はどんなものか、OR-Tools の Guide に載ってる例と図を拝借して書きます。 (https://developers.google.com/optimization/routing/vrp)\n  真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車を使い、各車は最大で4人まで利用者を載せられることとします。ノード内の数字は ID です。\nVRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。\nちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。 ありがたいことに Google Map には Distance Matrix API があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。しかしこのAPIは上限があり、16個までしか配列を送れません。\ndistance matrix がわかったら DataModel を作成します。\nstruct DataModel { const std::vectorstd::vectorint64_t distance_matrix{ {0, 548, 776, 696, 582, 274, 502, 194, 308, 194, 536, 502, 388, 354, 468, 776, 662}, {548, 0, 684, 308, 194, 502, 730, 354, 696, 742, 1084, 594, 480, 674, 1016, 868, 1210}, {776, 684, 0, 992, 878, 502, 274, 810, 468, 742, 400, 1278, 1164, 1130, 788, 1552, 754}, {696, 308, 992, 0, 114, 650, 878, 502, 844, 890, 1232, 514, 628, 822, 1164, 560, 1358}, {582, 194, 878, 114, 0, 536, 764, 388, 730, 776, 1118, 400, 514, 708, 1050, 674, 1244}, {274, 502, 502, 650, 536, 0, 228, 308, 194, 240, 582, 776, 662, 628, 514, 1050, 708}, {502, 730, 274, 878, 764, 228, 0, 536, 194, 468, 354, 1004, 890, 856, 514, 1278, 480}, {194, 354, 810, 502, 388, 308, 536, 0, 342, 388, 730, 468, 354, 320, 662, 742, 856}, {308, 696, 468, 844, 730, 194, 194, 342, 0, 274, 388, 810, 696, 662, 320, 1084, 514}, {194, 742, 742, 890, 776, 240, 468, 388, 274, 0, 342, 536, 422, 388, 274, 810, 468}, {536, 1084, 400, 1232, 1118, 582, 354, 730, 388, 342, 0, 878, 764, 730, 388, 1152, 354}, {502, 594, 1278, 514, 400, 776, 1004, 468, 810, 536, 878, 0, 114, 308, 650, 274, 844}, {388, 480, 1164, 628, 514, 662, 890, 354, 696, 422, 764, 114, 0, 194, 536, 388, 730}, {354, 674, 1130, 822, 708, 628, 856, 320, 662, 388, 730, 308, 194, 0, 342, 422, 536}, {468, 1016, 788, 1164, 1050, 514, 514, 662, 320, 274, 388, 650, 536, 342, 0, 764, 194}, {776, 868, 1552, 560, 674, 1050, 1278, 742, 1084, 810, 1152, 274, 388, 422, 764, 0, 798}, {662, 1210, 754, 1358, 1244, 708, 480, 856, 514, 468, 354, 844, 730, 536, 194, 798, 0}, }; const int num_vehicles = 4; const RoutingIndexManager::NodeIndex depot{0}; }; この DataModel を使って RoutingIndexManager を作り、それを用いて RoutingModel を作成します。\nRoutingIndexManager manager(data.distance_matrix.size(), data.num_vehicles, data.depot); RoutingModel routing(manager); また、計算後の距離の callback を取得したいので RegisterTransitCallback() で callback を作成します。\nconst int transit_callback_index = routing.RegisterTransitCallback( [\u0026data, \u0026manager](int64_t from_index, int64_t to_index) - int64_t { // Convert from routing variable Index to distance matrix NodeIndex. auto from_node = manager.IndexToNode(from_index).value(); auto to_node = manager.IndexToNode(to_index).value(); return data.distance_matrix[from_node][to_node]; }); routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index); 次にパラメータ調整をします。\nSetGlobalSpanCostCoefficient() では各車両のルートの中で最も所要時間の長いルートをできるだけ小さくしようとする際に用いられる重み、コストです。 0 の場合は考慮がされないので、アルゴリズムは全車両合計の総走行時間が短くなるのであれば、ごく少数の車両に多くの利用者を割り当てて非常に長いルートを作成する一方、残りの車両にはゼロかごく少数の利用者だけを割り当てるような偏りの大きなルートができます。 デイケア事業においては持っているリソース (車両および人員) をできるだけフル活用し、あまり偏りが出ないようにしたいというケースが多いので、この値は調整する必要があります。\nrouting.AddDimension(transit_callback_index, 0, 3000, true, \"Distance\"); routing.GetMutableDimension(\"Distance\")-SetGlobalSpanCostCoefficient(100); 最後に SolveWithParameters() で結果が出力されます。結果を図示したもの↓\n  注意点としてはメタヒューリスティクスを用いているので最適性の保証はないです。つまり必ずしも全体最適解が求まるとは限りません。 条件によっては結果が悪くなるケース、複雑すぎて結果が出ないケースも出てくるので、その際にはパラメータで探索戦略を変えて試す必要があると思います。探索戦略には焼きなまし法、タブー探索法、貪欲法などあります。一部しか知らないので勉強してみる所存。(https://developers.google.com/optimization/routing/routing_options)\n非常に面白いツールなので色々触って遊んでみようと思います。\n","wordCount":"460","inLanguage":"en","datePublished":"2018-12-28T00:00:00Z","dateModified":"2018-12-28T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://nito95.github.io/posts/2018-12-28/"},"publisher":{"@type":"Organization","name":"nito95 blog","logo":{"@type":"ImageObject","url":"https://nito95.github.io/%3Clink%20/%20abs%20url%3E"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://nito95.github.io/ accesskey=h title="nito95 blog (Alt + H)">nito95 blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://nito95.github.io/about/ title=About>
<span>About</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
OR-Tools で解く Vehicle Routing Problem
</h1>
<div class=post-meta>December 28, 2018
</div>
</header>
<div class=post-content><p>現在、自分は SmartDrive Fleet という SaaS プロダクトを担当しています。
デバイスを従業員の車両に取り付けることで、車両管理や運転日報、安全運転診断やジオフェンシングといった機能をWebやアプリで提供しています。</p>
<p>ユーザーの業種は幅広いのですが、その中でも介護・福祉業界のユーザーが一定の割合を占めています。
例えばデイケアの事業所では朝夕に利用者を送迎する必要があり、同じ時間帯に同時に3~4台、規模によっては10~20台前後の車を使うことがあります。</p>
<p>各利用者は家にピックアップする時間がそれぞれ決まっており、事業所に来る、つまりサービスを受け始める時間も決まっているのでなかなかシビアな朝の迎えをしています。
事業所の人は円滑に送迎が行われているのか管理をする必要があり、助手席に座るもう一人のスタッフが電話をして逐一報告を管理者にしている形態をとっていました。
それを SmartDrive Fleet を使うことで助手席の人はいらなくなり、リアルタイムでどこにいるのか管理ができるという使われ方をしています。</p>
<p>SmartDrive Fleet を使っているいくつかのデイケアの事業所の方から 「利用者に休みが出たり、体験入所で新たに送迎する利用者が出たりするときにルートを計画するのがとても大変。土地勘のある人が非常に時間をかけて計画表を作る必要がある。」という話を受けました。</p>
<p>これを解決するためのツールはないかなと探していると <a href=https://developers.google.com/optimization>Google OR-Tools</a> というライブラリを発見したのでこれを試しに使ってみました。</p>
<p>OR-Tools は Google 製の最適化ツールです。線型計画法、貢献度分配問題、ナップサック問題、巡回セールスマン問題など様々な最適化問題を扱えます。
OR-ToolsはOSSで無料で使えて、言語は Python, C++, C#, Java に対応しています。今回はC++で試してみます。</p>
<p>今回やりたい送迎ルート作成問題は Vehicle Routing Problem (以下 VRP) であり、VRP は OR-Tools で解くことができます。
VRP は <a href=https://ja.wikipedia.org/wiki/NP%E5%9B%B0%E9%9B%A3>NP-hard (NP困難)</a> に分類される問題で、計算完了までのかかる時間が指数関数的に増えるとされています。
OR-ToolsではVRPを数理的に解いていますが、他にディープラーニングの応用や量子コンピュータといったアプローチも取られているみたいです。</p>
<p>VRP はどんなものか、OR-Tools の Guide に載ってる例と図を拝借して書きます。 (<a href=https://developers.google.com/optimization/routing/vrp>https://developers.google.com/optimization/routing/vrp</a>)</p>
<figure>
<img loading=lazy src=/images/2018-12-28-1.svg width=600>
</figure>
<p>真ん中の黒ノードが事業所、青ノードがピックアップする利用者宅とし、4台の車を使い、各車は最大で4人まで利用者を載せられることとします。ノード内の数字は ID です。</p>
<p>VRP を解くのに必要なのは、あるノードからあるノードへの距離情報です。17ノードあるので 17 * 17 のマトリックスで距離を表します。</p>
<p>ちなみに OR-Tools を実際にプロダクトに使う場合は、各利用者の地点座標からこのマトリックスを作る必要があります。
ありがたいことに Google Map には <a href=https://developers.google.com/optimization/routing/vrp#distance_matrix_api>Distance Matrix API</a> があり、住所を配列で送ることで各住所間の距離をマトリックスで返してくれます。しかしこのAPIは上限があり、16個までしか配列を送れません。</p>
<p>distance matrix がわかったら <code>DataModel</code> を作成します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DataModel</span> {
    <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int64_t</span><span style=color:#f92672>&gt;&gt;</span> distance_matrix{
        {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>548</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>468</span>,
         <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>662</span>},
        {<span style=color:#ae81ff>548</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>684</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>594</span>, <span style=color:#ae81ff>480</span>, <span style=color:#ae81ff>674</span>,
         <span style=color:#ae81ff>1016</span>, <span style=color:#ae81ff>868</span>, <span style=color:#ae81ff>1210</span>},
        {<span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>684</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>992</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>1130</span>,
         <span style=color:#ae81ff>788</span>, <span style=color:#ae81ff>1552</span>, <span style=color:#ae81ff>754</span>},
        {<span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>992</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>844</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>1232</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>822</span>,
         <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>560</span>, <span style=color:#ae81ff>1358</span>},
        {<span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>1118</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>708</span>,
         <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>674</span>, <span style=color:#ae81ff>1244</span>},
        {<span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>228</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>240</span>, <span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>514</span>,
         <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>708</span>},
        {<span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>228</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>1004</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>856</span>, <span style=color:#ae81ff>514</span>,
         <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>480</span>},
        {<span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>320</span>, <span style=color:#ae81ff>662</span>,
         <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>856</span>},
        {<span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>844</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>320</span>,
         <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>514</span>},
        {<span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>240</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>274</span>,
         <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>468</span>},
        {<span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>1232</span>, <span style=color:#ae81ff>1118</span>, <span style=color:#ae81ff>582</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>342</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>730</span>,
         <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>1152</span>, <span style=color:#ae81ff>354</span>},
        {<span style=color:#ae81ff>502</span>, <span style=color:#ae81ff>594</span>, <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>400</span>, <span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>1004</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>878</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>308</span>,
         <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>844</span>},
        {<span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>480</span>, <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>890</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>696</span>, <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>114</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>536</span>,
         <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>},
        {<span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>674</span>, <span style=color:#ae81ff>1130</span>, <span style=color:#ae81ff>822</span>, <span style=color:#ae81ff>708</span>, <span style=color:#ae81ff>628</span>, <span style=color:#ae81ff>856</span>, <span style=color:#ae81ff>320</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>308</span>, <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>342</span>,
         <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>536</span>},
        {<span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>1016</span>, <span style=color:#ae81ff>788</span>, <span style=color:#ae81ff>1164</span>, <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>320</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>388</span>, <span style=color:#ae81ff>650</span>, <span style=color:#ae81ff>536</span>, <span style=color:#ae81ff>342</span>,
         <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>194</span>},
        {<span style=color:#ae81ff>776</span>, <span style=color:#ae81ff>868</span>, <span style=color:#ae81ff>1552</span>, <span style=color:#ae81ff>560</span>, <span style=color:#ae81ff>674</span>, <span style=color:#ae81ff>1050</span>, <span style=color:#ae81ff>1278</span>, <span style=color:#ae81ff>742</span>, <span style=color:#ae81ff>1084</span>, <span style=color:#ae81ff>810</span>, <span style=color:#ae81ff>1152</span>, <span style=color:#ae81ff>274</span>, <span style=color:#ae81ff>388</span>,
         <span style=color:#ae81ff>422</span>, <span style=color:#ae81ff>764</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>798</span>},
        {<span style=color:#ae81ff>662</span>, <span style=color:#ae81ff>1210</span>, <span style=color:#ae81ff>754</span>, <span style=color:#ae81ff>1358</span>, <span style=color:#ae81ff>1244</span>, <span style=color:#ae81ff>708</span>, <span style=color:#ae81ff>480</span>, <span style=color:#ae81ff>856</span>, <span style=color:#ae81ff>514</span>, <span style=color:#ae81ff>468</span>, <span style=color:#ae81ff>354</span>, <span style=color:#ae81ff>844</span>, <span style=color:#ae81ff>730</span>, <span style=color:#ae81ff>536</span>,
         <span style=color:#ae81ff>194</span>, <span style=color:#ae81ff>798</span>, <span style=color:#ae81ff>0</span>},
    };
    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> num_vehicles <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
    <span style=color:#66d9ef>const</span> RoutingIndexManager<span style=color:#f92672>::</span>NodeIndex depot{<span style=color:#ae81ff>0</span>};
};
</code></pre></div><p>この <code>DataModel</code> を使って <code>RoutingIndexManager</code> を作り、それを用いて <code>RoutingModel</code> を作成します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>RoutingIndexManager <span style=color:#a6e22e>manager</span>(data.distance_matrix.size(), data.num_vehicles,
                            data.depot);
RoutingModel <span style=color:#a6e22e>routing</span>(manager);
</code></pre></div><p>また、計算後の距離の callback を取得したいので <code>RegisterTransitCallback()</code> で callback を作成します。</p>
<pre><code>const int transit_callback_index = routing.RegisterTransitCallback(
    [&amp;data, &amp;manager](int64_t from_index, int64_t to_index) -&gt; int64_t {
      // Convert from routing variable Index to distance matrix NodeIndex.
      auto from_node = manager.IndexToNode(from_index).value();
      auto to_node = manager.IndexToNode(to_index).value();
      return data.distance_matrix[from_node][to_node];
    });
routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index);
</code></pre><p>次にパラメータ調整をします。</p>
<p><code>SetGlobalSpanCostCoefficient()</code> では各車両のルートの中で最も所要時間の長いルートをできるだけ小さくしようとする際に用いられる重み、コストです。
<code>0</code> の場合は考慮がされないので、アルゴリズムは全車両合計の総走行時間が短くなるのであれば、ごく少数の車両に多くの利用者を割り当てて非常に長いルートを作成する一方、残りの車両にはゼロかごく少数の利用者だけを割り当てるような偏りの大きなルートができます。
デイケア事業においては持っているリソース (車両および人員) をできるだけフル活用し、あまり偏りが出ないようにしたいというケースが多いので、この値は調整する必要があります。</p>
<pre><code>routing.AddDimension(transit_callback_index, 0, 3000, true, &quot;Distance&quot;);
routing.GetMutableDimension(&quot;Distance&quot;)-&gt;SetGlobalSpanCostCoefficient(100);
</code></pre><p>最後に <code>SolveWithParameters()</code> で結果が出力されます。結果を図示したもの↓</p>
<figure>
<img loading=lazy src=/images/2018-12-28-2.svg width=600>
</figure>
<p>注意点としてはメタヒューリスティクスを用いているので最適性の保証はないです。つまり必ずしも全体最適解が求まるとは限りません。
条件によっては結果が悪くなるケース、複雑すぎて結果が出ないケースも出てくるので、その際にはパラメータで探索戦略を変えて試す必要があると思います。探索戦略には焼きなまし法、タブー探索法、貪欲法などあります。一部しか知らないので勉強してみる所存。(<a href=https://developers.google.com/optimization/routing/routing_options>https://developers.google.com/optimization/routing/routing_options</a>)</p>
<p>非常に面白いツールなので色々触って遊んでみようと思います。</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://nito95.github.io/tags/vrp/>VRP</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://nito95.github.io/posts/2020-01-14/>
<span class=title>« Prev Page</span>
<br>
<span>Design Docを書く文化</span>
</a>
<a class=next href=https://nito95.github.io/posts/2018-12-11/>
<span class=title>Next Page »</span>
<br>
<span>F1 2018のTelemetryをGoでパースしてInfluxDBに流してGrafanaで描画してみる</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://nito95.github.io/>nito95 blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>